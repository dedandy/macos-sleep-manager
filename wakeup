#!/bin/bash

# Configurazione
LOG_FILE="$HOME/.sleeplog_history"
APPS_KILLED="$HOME/.sleep_killed_apps"
APPS_PENDING="$HOME/.sleep_pending_apps"

# -----------------------------------------------------------
# LISTA APP PESANTI (DA POSTICIPARE SE A BATTERIA)
# -----------------------------------------------------------
HEAVY_APPS_SKIP="Google Chrome|Firefox|Adobe Photoshop|Adobe Premiere Pro|DaVinci Resolve|Blender|Unreal Editor|Unity"

# Funzione di logging
log_message() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" >> "$LOG_FILE"
}

# Funzione per lanciare un'app (usata sia subito che dopo)
launch_app() {
    local app_name="$1"
    if open -a "$app_name"; then
        log_message "‚úÖ Riaperta: $app_name"
    else
        # Fallback: cerca il percorso
        app_path=$(find /Applications -name "$app_name.app" -maxdepth 2 2>/dev/null | head -n 1)
        if [ -z "$app_path" ]; then
            app_path=$(find ~/Applications -name "$app_name.app" -maxdepth 2 2>/dev/null | head -n 1)
        fi
        
        if [ -n "$app_path" ]; then
            open "$app_path"
            log_message "‚úÖ Riaperta (da path): $app_name"
        else
            log_message "‚ùå Errore: Impossibile trovare $app_name"
        fi
    fi
}

# 1. Attesa iniziale per stabilit√† sistema
sleep 10

# Pulizia vecchi pending se per caso rimasti
rm -f "$APPS_PENDING"

# 2. Controllo Fonte di Alimentazione Iniziale
IS_ON_BATTERY=false
if pmset -g batt | grep -q "Source: Battery Power"; then
    IS_ON_BATTERY=true
    log_message "üîã Alimentazione: BATTERIA. Modalit√† Smart-Wait attiva."
else
    log_message "‚ö°Ô∏è Alimentazione: CORRENTE. Ripristino completo."
fi

# 3. Ripristino Immediato (o accodamento)
if [ -f "$APPS_KILLED" ]; then
    log_message "üîÑ Analisi app da ripristinare..."
    
    while read -r app_name; do
        if [ -n "$app_name" ]; then
            
            should_defer=false
            
            # Se siamo a batteria E l'app √® pesante -> METTI IN ATTESA
            if [ "$IS_ON_BATTERY" = true ]; then
                if echo "$app_name" | grep -qE "$HEAVY_APPS_SKIP"; then
                    should_defer=true
                fi
            fi
            
            if [ "$should_defer" = true ]; then
                echo "$app_name" >> "$APPS_PENDING"
                log_message "‚è≥ POSTICIPATO: $app_name (In attesa di alimentazione...)"
            else
                launch_app "$app_name"
                sleep 0.5
            fi
        fi
    done < "$APPS_KILLED"
    
    rm "$APPS_KILLED"
else
    log_message "‚ÑπÔ∏è Nessuna app da ripristinare"
fi

# 4. MONITORAGGIO IN BACKGROUND (Se ci sono app in attesa)
if [ -f "$APPS_PENDING" ]; then
    log_message "üëÄ Avvio monitoraggio alimentazione per 5 minuti..."
    
    # Avvia una subshell in background che non blocca il terminale
    (
        # Tenta per 30 volte (30 * 10 sec = 300 sec = 5 minuti)
        for i in {1..30}; do
            sleep 10
            
            # Controlla se ORA √® collegata la corrente
            if ! pmset -g batt | grep -q "Source: Battery Power"; then
                # EUREKA! Corrente collegata
                echo "$(date '+%Y-%m-%d %H:%M:%S') - ‚ö°Ô∏è CORRENTE RILEVATA! Apro app in attesa..." >> "$LOG_FILE"
                
                while read -r pending_app; do
                    # Logica di apertura inline (perch√© siamo in subshell)
                    if open -a "$pending_app"; then
                         echo "$(date '+%Y-%m-%d %H:%M:%S') - ‚úÖ Riaperta (Delayed): $pending_app" >> "$LOG_FILE"
                    else
                         # Tentativo semplificato path standard
                         open "/Applications/$pending_app.app" 2>/dev/null || \
                         echo "$(date '+%Y-%m-%d %H:%M:%S') - ‚ùå Fallito delay open: $pending_app" >> "$LOG_FILE"
                    fi
                    sleep 1
                done < "$APPS_PENDING"
                
                rm "$APPS_PENDING"
                exit 0
            fi
        done
        
        # Se finisce il ciclo e siamo ancora qui, tempo scaduto
        echo "$(date '+%Y-%m-%d %H:%M:%S') - ‚è± Tempo scaduto. App in attesa cancellate." >> "$LOG_FILE"
        rm "$APPS_PENDING"
    ) &
    
    # La & commerciale alla fine della parentesi manda tutto quel blocco in background
    # Lo script principale termina qui, lasciando il "vigilante" attivo.
fi

log_message "üèÅ Wakeup script terminato (monitoraggio in background se necessario)"